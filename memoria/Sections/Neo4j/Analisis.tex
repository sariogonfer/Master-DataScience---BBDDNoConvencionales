\section{Análisis}

Para este análisis vamos a realizar alguna de las consultas que ya hicimos en MongoDB y así podremos comparar ambas \gls{BBDD}.

\subsection{Listado de todas las publicaciones de un autor determinado.}

En primer lugar, vamos a hacer una busqueda de las publicaciones realizadas por un autor en concreto. Para esta busqueda, haremos un filtrado de los nodos que pertenezcan al subgrafo de autores, \textit{:Author}, y sobre estos filtraremos utilizando el atributo \textit{name} de estos nodos. Con esto tendremos el nodo del autor. A partir de este nodo, y siguiendo las relaciones de tipo \textit{:Writed} que tiene definidas como si de un camino se tratase, llegaremos a las publicaciones de este autor.

\begin{minted}[
frame=single]{sql}
MATCH (:Author {name: 'Chin-Wang Tao'})-[:Writed]->(p:Publication)
RETURN p.title
\end{minted}

Podemos comparar el efecto de aplicar un índice sobre este campo:

\begin{itemize}
 \item Sin índice: 1620 ms
 \item Con índice: 80 ms
\end{itemize}


\subsection{Número de artículos en revistas para el año 2017.}

Para este caso necesitaremos hacer una agregación. En el caso de Cypher, no contamos con un framework de agregación tan flexible como el que nos ofrece MongoDB, pero aun así podemos realizar ciertas agregaciones. Para poder contar el número de articulos publicados en 2017, filtraremos los nodos pertenecientes al subgrafo \textit{:Article} utilizando el atributo \textit{year}. A continuación utilizamos la funcion \textbf{count()} para contar el número de estos.

\begin{minted}[
frame=single]{sql}
MATCH (p:Article {year: 2017})
RETURN count(p)
\end{minted}

Como en el caso anterior, comparamos los tiempos de carga con y sin índice:

\begin{itemize}
 \item Sin índice: 1160 ms
 \item Con índice: 970 ms
\end{itemize}

En este caso el índice apenas tiene efecto ya que el número de posibles valores es muy pequeño en comparación al número de elementos.

\subsection{Lista de coautores de un autor.}

En esta consulta aprovecharemos la potencia de las \gls{BBDD} orientadas a grafos, las relaciones. Mientras que en MongoDB la query necesaria incluía realizar (en caso de no querer tener demasiados elementos anidados) múltiples operaciones con el framework de agregaciones, en Neo4j podemos obtener la misma información con una query mínima. 

\begin{minted}[
frame=single]{sql}
MATCH (:Author {name: "Chin-Wang Tao"})-[:Writed]->(:Publication)<-[:Writed]-(c:Author)
RETURN c.name
\end{minted}

En este caso, la ejecución en Neo4j tardó 7 ms, mientras que en MongoDB, el tiempo de ejecución de la consulta similar fue de 5 ms. Se puede entender que el tiempo sea prácticamente idéntico, puesto que este caso de uso auna en una misma consulta relaciones y atributos de las entidades; por lo que el tiempo de ejecucion en MongoDB será muy bueno gracias a la buena gestión de atributos de documentos, mientras que Neo4J toma ventaja de las relaciones entre entidades.

\subsection{Edad de los 5 autores con el periodo de publicaciones más largo.}

Ahora vamos a intentar realizar una consulta menos amistosa para nuestra \gls{BBDD}.

\begin{minted}[
frame=single]{sql}
MATCH (a:Author)-[:Writed]->(p:Publication)
WITH a, max(p.year) - min(p.year) as age
RETURN a.name, age
ORDER BY age DESC LIMIT 5
\end{minted}

Aunque la consulta a priori parece secilla, incluso más que la que usamos en MongoDB, el tiempo de ejecución y la carga que le supone a la máquina es significativamente mayor, llegando ingluso a desbordar la memoria.

\section{Diferencias con MongoDB.}

MongoDB y Neo4j son dos \gls{BBDD} diferentes en su concepción. Mientras que MongoDB está orientada a documentos, Neo4j está orientada a grafos.

Durante la realización de esta práctica hemos podido sacar algunas conclusiones respecto al uso de ambas \gls{BBDD}:

\begin{itemize}
 \item La carga de los datos en Neo4j ha sido de largo, más complicada que en MongoDB. Esto se debe a las herramientas disponibles para realizar esta carga de datos, al menos, la primera carga, donde el uso de \textit{LOAD CSV} era inviable por el tiempo de carga. En el caso de hacer uso de \textit{neo4j-admin}, es necesario eliminar el grafo en caso de existir, además de ser sensible a errores (en versiones anteriores existía una opción que permitia definir un número máximo de errores permitidos y así poder tratarlos de manera individual a posteriori).
 \item La sintaxis que ofrece \textit{Cypher} resulta más sencilla, en especial a aquellas personas que venga del mundo \gls{SQL}.
 \item Neo4j demuestra su fortaleza a la hora de realizar consultas sobre relaciones entre nodos, pero palidece en aquellas consulta en las que hay que realizar operaciones con los atributos de estos. El uso de índices resulta útil en aquellos atributos que puedan tomar un gran número de posibles valores.
 \item MongoDB dispone de un framework para hacer agregaciones muy potente, aunque su curva de aprendizaje es muy empinada al principio.
 \item En la actualidad, MongoDB está presentando actualizaciones constantemente, ampliando a través de nuevas funcionalidades que los usuarios que venían del mundo SQL parecían echar de menos. Esto está consiguiendo que la expansión de utilización de MongoDB sea a un ritmo frenético.
\end{itemize}
